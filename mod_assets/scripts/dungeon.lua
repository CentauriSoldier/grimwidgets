-- This file has been generated by Dungeon Editor 1.3.6

--- level 1 ---

mapName("Unnamed")
setWallSet("dungeon")
playStream("assets/samples/music/dungeon_ambient.ogg")
mapDesc([[
################################
################################
################################
################################
################################
################################
################################
################################
################################
################################
################################
################################
################################
################################
##############...###############
##############......############
##############......############
##############....##############
################################
################################
################################
################################
################################
################################
################################
################################
################################
################################
################################
################################
################################
################################
]])
spawn("starting_location", 17,17,2, "starting_location")
spawn("torch_holder", 15,14,0, "torch_holder_1")
	:addTorch()
spawn("script_entity", 2,0,0, "gw_debug")
	:setSource("-- this is just a placeholder for debugging purposes.\
-- When debugging a script entity you can rename this script entity for example to gw and copy paste \
-- the script entity part from mod_assets/grimwidgets/gw.lua here. \
-- so the framwork will not load the script from that lua file.\
-- Same works with any dynamically loaded script entities.\
-- Problem with the dynamically loaded script enetites is that you can't see any errors in editor they might cause\
-- so you have to copy paste them to dungeon for debugging.\
\
\
")
spawn("script_entity", 12,15,3, "debug")
	:setSource("\
-- draws size*size grid and shows mouse coordinates in upper left corner\
-- you can enable it by calling debug.grid(100), disable: debug.grid() \
-- currently works only in fullscreen mode because of g.width g.height bug\
\
function grid(size)\
\9if not size then\
\9\9gw.removeElement('grid')\
\9\9return\
\9end\
\9size = size or 100\
\9local grid = {}\
\9grid.id = 'grid'\
\9grid.size = size\
\9grid.draw = function(self,g)\
\9\9local h = math.ceil(g.height/self.size)\
\9\9local w = math.ceil(g.width/self.size)\
\9\9for x = 0,w do\
\9\9\9g.drawRect(x*self.size,0,1,g.height)\
\9\9end\
\9\9for y = 0,h do\
\9\9\9g.drawRect(0,y*self.size,g.width,1)\
\9\9end\9\9\
\9\9g.drawText('x: '..g.mouseX..', y:'..g.mouseY,20,20)\
\9\9g.drawText('g.width - '..g.width - g.mouseX..', g.height - '..g.height - g.mouseY,20,40)\
\9end\
\9gw.addElement(grid)\
end\
\
function debugGrid()\
\9grid(100)\
end\
\
function disableGrid()\
\9grid()\
end")
spawn("dungeon_wall_text", 14,15,3, "dungeon_wall_text_1")
	:setWallText("Enable mouse grid")
spawn("gw_event", 16,16,2, "gw_event_1")
	:setSource("-- is this event enabled?\
enabled = true\
\
-- name of the imeage to show\
image = \"mod_assets/images/example-image.dds\"\
image_width = 177\
image_hieght = 180\
\
\
-- buttons position\
buttons_x = 220\
buttons_y = 160\
buttons_width = 200\
\
-- initial state\
state = 1\
\
-- functions called after specific buttons being pressed\
function onHeal()\
    hudPrint(\"Healing!\")\
    state = 2\
end\
\
function onTalk()\
    hudPrint(\"Dwarf is in too much pain to talk.\")\
end\
\
function onLeave()\
    enabled = false\
end\
\
function onHealed()\
    hudPrint(\"He is healed already!\")\
end\
\
-- defines states. Each entry must have exactly two columns:\
-- first is state number, the second is description shown.\
states = {\
  { 1, \"An injured dwarf lies on the ground before you,\\n\" ..\
       \"nearly unconscious from his wounds.\" },\
  { 2, \"The healed dwarf is happy.\" }\
}\
\
-- defines possible actions in each state. Each entry has\
-- 3 values. First is state number. Second is action name\
-- (will be printed on a button). The third is a function\
-- that will be called when action is taken (i.e. button\
-- is pressed).\
actions = {\
  { 1, \"tend his wounds\", onHeal },\
  { 1, \"talk\", onTalk },\
  { 1, \"leave\", onLeave},\
  { 2, \"healed\", onHealed}\
}\
")
spawn("script_entity", 29,31,2, "spell_book")
	:setSource("-- For testing/developement purposes\
-- I hope that this case is complex enough to show the possible flaws on grimwigets.\
\
spells = {}\
\
function getRuneImage(runeChar)\
\9local runeMap = {\
\9\9A='rune1_fire',\
\9\9B='rune2_death',\
\9\9C='rune3_air',\
\9\9D='rune4_spirituality',\
\9\9E='rune5_balance',\
\9\9F='rune6_physicality',\
\9\9G='rune7_earth',\
\9\9H='rune8_life',\
\9\9I='rune9_water'\
\9}\
\
\9return 'mod_assets/textures/'..runeMap[runeChar]..'.tga'\
end\
\
function getRunePosition(runeChar)\
\9local  positions = {\
\9\9A = {1,1},\
\9\9B = {2,1},\
\9\9C = {3,1},\
\9\9D = {1,2},\
\9\9E = {2,2},\
\9\9F = {3,2},\
\9\9G = {1,3},\
\9\9H = {2,3},\
\9\9I = {3,3}\9\9\9\9\9\9\
\9}\
\9return positions[runeChar]\
end\
\
function setSpells(pspells)\
\9spells = {}\
\9i = 1\
\9for spellName,def in pairs(pspells) do\
\9\9table.insert(spells,i,def)\
\9\9i = i + 1\
\9end\
end\
\
function createSpellBook()\
\9local book = gw_image.create('spell_book',20,20,900,800,'mod_assets/textures/book_900.tga')\
\9book.onDraw = function(self,ctx,champion) \
\9\9if champion and champion:getClass() ~= 'Mage' then\
\9\9\9return false\
\9\9end\9\9\
\9end\
\9\
\9local page1 = book:addChild('element','page1',20,20,350,500)\
\9local page2 = book:addChild('element','page2',490,30,350,500)\
\9\
\9for _,spell in ipairs(spells) do\
\9\9addSpell(book,spell)\
\9end\
\9\
\9return book\
\
end\
\
function addSpell(book,spell)\
\9page1 = book:getChild('page1')\
\9\
\9local line = page1:addChild('element',spell.name,0,20,200,30)\
\9\
\9line.marginLeft = 20\
\
\9line:setRelativePosition('below_previous')\
\9local bmemorize = line:addChild('button',spell.name..'_memo',0,0,' ')\
\9bmemorize.width = 10\
\9bmemorize.color = {0,0,0,100}\
\9local text = line:addChild('text',spell.name..'_text',0,0,300,20,spell.uiname)\
\9text.marginLeft = 10\
\9text.textColor = {150,150,150,200}\
\9text:setRelativePosition('after_previous')\
\9\
\9text.onClick = _turnPage\
\9\
\9local page2 = book:getChild('page2')\
\9\
\9local spellDescr = page2:addChild('element','runes_'..spell.name,0,0,350,400)\
\9spellDescr:deactivate()\
\9text.spellDescr = spellDescr\
\9\
\9local runes = spellDescr:addChild('element','runes_'..spell.name,0,0,240,240)\
\9runes:setRelativePosition{'top','center'}\
\9\
\9for _,runeChar in ipairs({'A','B','C','D','E','F','G','H','I'}) do\
\9\9\
\9\9local runeImg = runes:addChild('image','rune_'..runeChar,0,0,100,100,spell_book.getRuneImage(runeChar))\
\9\9local pos = spell_book.getRunePosition(runeChar)\
\9\9runeImg.x = pos[1] * 80 - 80\
\9\9runeImg.y = pos[2] * 80 - 80\
\9\9if not string.find(spell.runes,runeChar) then\
\9\9\9runeImg.color = {100,100,100,150}\
\9\9end\
\9end\9\9\
\9\
\9local spellText = spellDescr:addChild('text','spell_text_'..spell.name,0,250,350,200,spell.description)\
\9spellText.textColor = {150,150,150,200}\
\9spellText.textSize = 'medium'\
\
\9\
end\
\
function _turnPage(self)\
\9for i, elem in ipairs(self:getAncestor():getChild('page2').children) do\
\9\9elem:deactivate()\
\9end\
\9self.spellDescr:activate()\
end\
\
\
function autoexec()\
\9-- testing\
\9local testDescription = [[This is a testing spell definition.Lorem ipsum dolor sit amet, consectetur adipiscing elit. Proin iaculis pretium velit,\
commodo molestie augue adipiscing ac. In hac habitasse platea dictumst.\
Maecenas massa diam, accumsan sed mattis in, volutpat non elit. Maecenas ut ullamcorper nisi.]]\
\9\
\9setSpells{\
\9\9{name='fireburst',uiname='Fireburst',runes='A',description='Caster creates a quick burst of fire in front of him'},\
\9\9{name='ice_shards',uiname='Ice Shards',runes='GI',description='Caster shoots a flurry of ice shards in front of him'},\
\9\9{name='all_runes',uiname='test runes',runes='ABCDEFGHI',description=testDescription}\
\9}\
\9\
\9\9\
\9local book = spell_book.createSpellBook()\
\9gw.addElement(book,'skills')\
end\
")
spawn("script_entity", 28,31,2, "compass")
	:setSource("-- This example draws a compass as a GUI element. Depending on which\
-- activation mode is chosen, it can be visible all time, toggled\
-- with 'c' key or shown only when 'c' is pressed.\
\
-- draws actual compass\
-- this function is called when compass is visible all time\
function drawCompass(self, g)\
\9local x = 10\
\9local y = g.height - 200\
\9\
\9local dir = string.sub(\"NESW\", party.facing + 1, party.facing + 1)\
\9g.drawImage(\"mod_assets/textures/compass_full_\"..dir..\".tga\", x, y)\
end\
\
-- this is a simple wrapper function that is called as key press\
-- hook. It calls drawCompass function.\
function callback(g)\
\9drawCompass(self, g)\
end\
\
function autoexec()\
\9local e = {}\
\9e.id = 'compass'\
\9e.draw = drawCompass\
\9e.callback = callback\
\9\
\9-- uncomment this to enabled/disable compass by pressing C\
\9gw.setKeyHook('c', true, e.callback)\
\9\
\9-- Uncomment this to show compass by pressing C\
\9-- gw.setKeyHook('c', false, e.callback)\
\9\
\9-- Uncomment this to have compass permanently visible\
\9-- gw.addElement(e,'gui')\
end")
spawn("wall_button", 14,16,3, "wall_button_2")
	:addConnector("toggle", "gui_demo", "drawExample")
spawn("script_entity", 12,16,2, "gui_demo")
	:setSource("-- This function showcases how gwElements may be stacked together\
function drawExample()\
\
\9gw.setDefaultColor({200,200,200,255})\
\9gw.setDefaultTextColor({255,255,255,255})\
\
\9-- background yellow image\
\9local rect1 = gw_rectangle.create('rect1', 100, 50, 600, 350)\
\9rect1.color = {255, 255, 0}\
\9gw.addElement(rect1, 'gui')\
\9\
\9-- Example of image within \
\9local img1 = gw_image.create('image1', 0, 0, 177, 190, 'mod_assets/images/example-image.dds')\
\9rect1:addChild(img1)\
\9img1:setRelativePosition({'right','bottom'})\
\9\
\9local button1 = gw_button3D.create('button1', 70, 10, \"3D-ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\
\9button1.textColor = {200,100,0}\
\9\
\9button1.onClick = function(self) print(self.id..' clicked') end\
\9rect1:addChild(button1)\
\9button1:setRelativePosition({'left','bottom'})\
\9\
\9local button2 = gw_button.create('button2', 70, 40, \"abcdefghijklmnopqrstuvwxyz\")\
\9button2.onPress = function(self) print(self.id..' clicked') end\
\9rect1:addChild(button2)\
\
\9\
\9local button3 = gw_button.create('button3', 70, 70, \"1234567890\")\9\
\9button3.color = button1.color\
\9button3.onPress = function(self) print(self.id..' clicked') end\
\9rect1:addChild(button3)\
\9\9\
\
\9-- Create directly to parent example\
\9local button4 = rect1:addChild('button','button4', 70, 100, \"!@#$%^&*()-,.'\")\
\9button4.color = button1.color\
\9button4.onPress = function(self) print(self.id..' clicked') end\
\
\9local button5 = rect1:addChild('button','button5', 70, 100, \"After element position\")\
\9button5.color = button1.color\
\9button5:setRelativePosition({'after','button4'})\
\9button5.marginLeft = 10\
\9\
\9local button6 = rect1:addChild('button','button6', 70, 100, \"Below element position\")\
\9button6:setRelativePosition{'below','button5'}\
\9button6.marginLeft = 10\
\9button6.marginTop = 15\
\9\
\9local button7 = rect1:addChild('button','button7', 70, 100, \"After button5\")\
\9button7.color = button1.color\
\9button7:setRelativePosition({'after','button5'})\
\9button7.marginLeft = 10\9\
\9\
\9rect2 = rect1:addChild('rectangle','rect2', 0, 0, 50, 50)\
\9rect2.color={0, 0, 255}\
\9rect2:setRelativePosition{'left','top'}\
\9\
\9local rect3 = rect2:addChild('rectangle','rect3', 0, 0, 30, 40) -- rect3 in rect2, which is in rect1\
\9rect3:setRelativePosition{'top','left'}\
\9rect3.marginTop = 5\
\9rect3.marginLeft = 10\
\9rect3.color = {255, 0, 0}\
\9rect3.onPress = function(self) \
\9\9print('rectangles can be clicked too')\
\9end\
\
\9local text1 = rect1:addChild('text','text1',0,0,200,180)\
\9text1:setRelativePosition{'bottom','center'}\
\9\
\9text1.text = \"Long text should be wrapped automatically. Does\\nit\\nwork? Some more words here for testing purposes\"\
\9text1.textColor = {0,255,255}\
\9\
\9local closeButton = rect1:addChild('button3D','close_rect_1',20,20,'X',30,20)\
\9closeButton.onPress = function(self)\
\9\9gw.removeElement('rect1')\
\9end\
\9closeButton:setRelativePosition({'top','right'})\
\9\
\9\
\9\
end\
")
spawn("dungeon_wall_text_long", 14,16,3, "dungeon_wall_text_long_1")
	:setWallText("Shows gwElements (several gui elements\
that are hierarchically organized)")
spawn("script_entity", 0,0,1, "logfw_init")
	:setSource("spawn(\"LoGFramework\", party.level,1,1,0,'fwInit')\
fwInit:open() \
function main()\
   fw.debug.enabled = false\
   fwInit:close()\
end")
spawn("dungeon_door_portcullis", 18,16,3, "dungeon_door_portcullis_1")
spawn("dungeon_door_portcullis", 18,15,3, "dungeon_door_portcullis_2")
spawn("snail", 19,15,0, "snail_1")
spawn("wall_button", 14,14,3, "wall_button_3")
	:addConnector("toggle", "new_champion", "newChampion")
spawn("dungeon_wall_text", 14,14,3, "dungeon_wall_text_2")
	:setWallText("Use this button to get someone new\
in your party! The more the merrier!")
spawn("script_entity", 12,14,2, "new_champion")
	:setSource("function newChampion()\
\9newguy = {\
\9\9name = \"Taghor\",    -- just a name\
\9\9race = \"Insectoid\", -- must be one of: Human, Minotaur, Lizardman, Insectoid\
\9\9class = \"Mage\",     -- must be one of: Figther, Rogue, Mage or Ranger\
\9\9sex = \"male\", \9\9-- must be one of: male, female\
\9\9level = 3,          -- character's level\
\9\9portrait = \"mod_assets/textures/portraits/taghor.dds\", -- must be 128x128 dds file\
\9\9\
\9\9-- allowed skills: air_magic, armors, assassination, athletics, axes, daggers, \
\9\9-- dodge, earth_magic, fire_magic, ice_magic, maces, missile_weapons, spellcraft,\
\9\9-- staves, swords, throwing_weapons and unarmed_combat\
\9\9skills = { fire_magic = 10, earth_magic = 20, air_magic = 30, ice_magic = 40 },\
\9\9\9\9\
\9\9-- allowed traits: aggressive, agile, athletic, aura, cold_resistant, evasive, \
\9\9-- fire_resistant, fist_fighter, head_hunter, healthy, lightning_speed,\
\9\9-- natural_armor, poison_resistant, skilled, strong_mind, tough\
\9\9-- Traits must be specified in quotes.\
\9\9-- Typically each character has 2 traits, but you can specify more or less.\
\9\9traits = { \"lightning_speed\", \"tough\", \"skilled\", \"head_hunter\", \"aura\" },\
\9\9\
\9\9health = 80, \9\9  -- Maximum health\
\9\9current_health = 70,  -- Current health\
\9\9\
\9\9energy = 300,         -- Maximum energy\
\9\9current_energy = 250, -- Current energy\
\
\9\9strength = 12,        -- Strength\
\9\9dexterity = 11,       -- Dexterity\
\9\9vitality = 10,        -- Vitality\
\9\9willpower = 9,        -- Willpower\
\9\9\
\9\9protection = 25,      -- protection\
\9\9evasion = 30, \9\9  -- evasion\
\9\9\9\9\
\9\9-- Resist fire/cold/poison/shock (remember that those values will be modified by bonuses\
\9\9-- from fire, cold, poison or shock magic\
\9\9resist_fire = 11,\
\9\9resist_cold = 22,\
\9\9resist_poison = 33,\
\9\9resist_shock = 44,\
\9\9\
\9\9-- items: Notation item_name = slot. Slots numbering: 1 (head), 2 (torso), 3 (legs), 4 (feet), \
\9\9-- 5 (cloak), 6 (neck), 7 (left hand), 8 (right hand), 9 (gaunlets), 10 (bracers), 11-31 (backpack\
\9\9-- slots) or 0 (any empty slot in backpack)\
\9\9-- Make sure you put things in the right slot. Wrong slot (e.g. attempt to try boots on head)\
\9\9-- will make the item spawn to fail.\
\9\9items = { battle_axe = 0, lurker_hood = 1, lurker_vest = 2, lurker_pants = 3, lurker_boots = 4 },\
\9\9\
\9\9-- food: 0 (starving) to 1000 (just ate the whole cow)\
\9\9food = 100\
\9\9\
\9}\
\
\9-- Call addChampion method. It will add new guy to the party if there are suitable slots and will\
\9-- display a GUI prompt selecting a party member to drop if your party is already 4 guys\
\9gw_party.addChampion(newguy)\
end\
\
")
spawn("lightning_rod", 14,14,3, "lightning_rod_1")
spawn("sack", 15,15,3, "sack_1")
spawn("rock", 15,15,1, "rock_1")
spawn("rock", 15,15,0, "rock_2")
spawn("lever", 14,15,3, "lever_1")
	:addConnector("activate", "debug", "debugGrid")
	:addConnector("deactivate", "debug", "disableGrid")
spawn("script_entity", 14,19,2, "quickDialog_demo")
	:setSource("--\
-- Example of the Dialog.quickDialog() function\
-- \
-- It enables you to start a dialog with a close button by starting one function.\
-- Tip: use [[ and ]] to define a multiple-line-string.\
--\
\
function press()\
\9Dialog.quickDialog([[This is an example of the dialog system.\
\
Dialog code was written by Mahric for Legends\
of the Northern Realms mod. It is being merged\
with grimwidgets by Thomson. This is a work\
in progress.\
\
Features:\
 - Grimrock style interface\
 - Automatically resizing window and buttons\
 - Text appears on screen, as if being told\
 - Optional portrait of npc you talk to\
\
Check the wiki for more info how to use it,\
But first see if you can get out of here...]], clicked)\
end\
\
function clicked()\
\9hudPrint(\"Why did you close this awesome looking dialog?\")\
end")
spawn("wall_button", 14,17,2, "wall_button_1")
	:addConnector("toggle", "quickDialog_demo", "press")
spawn("wall_button", 15,17,2, "wall_button_4")
	:addConnector("toggle", "quickDialog_simple", "clickOgre")
spawn("script_entity", 15,19,1, "quickDialog_simple")
	:setSource("--\
-- Example on how to build your own dialog\
-- \
-- This example uses all features:\
--  * Shows portrait of the npc\
--  * Defines buttons with custom text\
--  * Uses a callback function to process the result\
--\
\
s_challenge = \"Right, make me!\"\
s_agree = \"I'm going already!\"\
\
function clickOgre()\
\9local s_npcId = \"\" -- \"npc_guard\"\
\9local s_text = [[Hey, you!\
\9\9\9\9\9What are you doing here? Why are you pressing\
\9\9\9\9\9this button?\
\
\9\9\9\9\9You're not supposed to be here.\
\9\9\9\9\9Leave while you can!]]\
\
\9local s_dlgId = Dialog.new(s_text, s_agree, nil) --s_npcId)\
\9Dialog.addButton(s_dlgId, s_challenge)\
\9Dialog.activate(s_dlgId, ogreCallBack)\
end\
\
function ogreCallBack(s_caption)\
\9if s_caption == s_challenge then\
\9\9hudPrint(\"Oh oh... Now you've done it!\")\
\9end\
\9if s_caption == s_agree then\
\9\9hudPrint(\"Party is full of chickens!\")\
\9end\
end")
spawn("wall_button", 16,17,2, "wall_button_5")
	:addConnector("toggle", "quickDialog_yesno", "yesNoQuestion")
spawn("script_entity", 16,19,1, "quickDialog_yesno")
	:setSource("--\
-- Example on how to build your own yes/now dialog\
-- \
\
s_challenge = \"Right, make me!\"\
s_agree = \"I'm going already!\"\
\
function yesNoQuestion()\
\9local s_text = [[Hey, you! Are you brave?]]\
\
\9local s_dlgId = Dialog.quickYesNoDialog(s_text, answerCallBack, nil)\
\9Dialog.activate(s_dlgId, answerCallback)\
end\
\
function answerCallBack(s_caption)\
\9if s_caption == \"Yes\" then\
\9\9hudPrint(\"Yeah, right...\")\
\9end\
\9if s_caption == \"No\" then\
\9\9hudPrint(\"Run for your life! There's killer snail after you\")\
\9end\
end")
spawn("wall_button", 17,17,2, "wall_button_6")
	:addConnector("toggle", "MergedDemo", "drawExample")
spawn("script_entity", 17,19,0, "MergedDemo")
	:setSource("function drawExample()\
\
\9gw.setDefaultColor({200,200,200,255})\
\9gw.setDefaultTextColor({255,255,255,255})\
\
\9-- background yellow image\
\9local rect1 = Dialog.create(-1, -1, 600, 150)\
\9rect1.dialog.text = \"THis is a slow appearing text\"\
\9rect1.color = {255, 255, 0}\
\9\
\9local img1 = gw_button3D.create('img', 10, 10, \"Awesome!\", 300, 40)\
\9rect1:addChild(img1)\
\9img1:setRelativePosition({'center','bottom'})\
\9img1.onClick = click\
\9\
\9gw.addElement(rect1, 'gui')\
end\
\
function click()\
\9gw.removeElement(\"Dialog\")\
end")
spawn("script_entity", 15,8,3, "Dialog2")
	:setSource("\
\
tDialog = {\
\9dialogs = {},\9\9\9-- Contrains definition of all defined dialogs\
--\9activeDialog = nil,\9\9-- ID of dialog currently on screen\
\9startedAt = nil,\9\9-- Time_played the dialog was first shown\
}\
\
-- This method creates a gw_element that represents a dialog.\
-- It is not really a proper gw_element, but it is sufficient to have its drawSelf\
-- method called. That is enough for now to plug Dialog into grimwidgets.\
function create(x, y, width, height)\
\9local elem = gw_element.create(\"Dialog\", x, y, width, height)\
\9elem.drawSelf = onDraw\
\9elem.dialog = { id = Util.String_GenerateUUID(\"dlg_\"),\
\9\9        text = \"\",\
\9\9\9buttons = {},\
\9\9\9npc = nil,\
\9\9\9callBack = nil}\
\9table.insert(tDialog.dialogs, s_newDialog)\
\9tDialog.startedAt = getStatistic(\"play_time\")\
\
\9return elem\
end\
\
function new(s_text, s_buttonText, s_npc, s_id)\
\
\9-- Check parameters; mandatory and/or type checking\
\9if type(s_text) == \"string\" and type(s_buttonText) == \"string\" and (s_npc == nil or type(s_npc) == \"string\") and (s_id == nil or type(s_id) == \"string\") then\
\
\9\9-- if no id is given, create a random one\
\9\9if s_id == \"\" or s_id == nil then\
\9\9\9s_id = Util.String_GenerateUUID(\"dlg_\")\
\9\9end\
\
\9\9-- Get definition of existing dialog with that id\
\9\9if getDialog(s_id) == nil then\
\9\9\
\9\9\9-- Create a new dialog if none exists with that id\
\9\9\9local s_newDialog = { id = s_id,\
\9\9\9\9\9\9\9\9  text = s_text,\
\9\9\9\9\9\9\9\9  buttons = {s_buttonText},\
\9\9\9\9\9\9\9\9  npc = s_npc,\
\9\9\9\9\9\9\9\9  callBack = nil,\
\9\9\9\9\9\9\9\9}\
\9\9\9table.insert(tDialog.dialogs, s_newDialog)\
\9\9end\
\9\9\
\9\9return s_id\
\9else\
\9\9print(\"Calling dialog.new() with wrong number and/or type of parameters.\")\
\9end\
end\
\
\
function addButton(s_id, s_buttonText)\
\
\9-- Check parameters; mandatory and/or type checking\
\9if type(s_id) == \"string\" and type(s_id) == \"string\" then\
\9\
\9\9table.insert(getDialog(s_id).buttons, 1, s_buttonText)\
\9\9\
\9else\
\9\9print(\"Calling dialog.addButton() with wrong number and/or type of parameters.\")\
\9end\
end\
\
\
function activate(s_id, f_callBack)\
\
\9-- Check parameters; mandatory and/or type checking\
\9if type(s_id) == \"string\" and (f_callBack == nil or type(f_callBack)==\"function\") then\
\
\9\9-- Get dialog definition\
\9\9local t_dlg = getDialog(s_id)\
\9\9if t_dlg then\
\9\9\9\
\9\9\9-- Make fetched dialog the active dialog\
\9\9\9t_dlg.callBack = f_callBack\
\9\9\9tDialog.startedAt = getStatistic(\"play_time\")\
\
\9\9\9-- We need to create a gw_element. It will be called from gw framework.\
\9                -- It will not draw anything on its own, just will call onDraw() method. It\
                        -- will be removed when deactivate() method is called.\
\
                        -- x, y, width, height all set to -1 (set it automatically)\
                        local h_glue = create(-1, -1, -1, -1)\
                        h_glue.dialog = t_dlg\
                        gw.addElement(h_glue, 'gui')\
\
\9\9end\
\9else\
\9\9print(\"Calling dialog.activate() with wrong number and/or type of parameters.\")\
\9\9return\
\9end\
\
end\
\
function deactivate()\
\9-- remove any active dialog (if any)\
\9tDialog.startedAt = nil\
\
\9-- remove active hooks from grimwidgets. Dialog.onDraw() method will no longer\
\9-- be called\
\9gw.removeElement(\"Dialog\", 'gui')\
end\
\
function quickYesNoDialog(s_text, f_callBack, s_npc)\
\
\9-- Check parameters; mandatory and/or type checking\
\9if type(s_text) == \"string\" and (f_callBack == nil or type(f_callBack == \"function\")) and (s_npc == nil or type(s_npc)==\"string\") then\
\9\
\9\9-- Use standard id and get current dialogdefinition\
\9\9local s_id = \"dlgQuickYesNo\"\
\9\9local t_dlg = getDialog(s_id)\
\
\9\9-- Make a new dialogdefinition if none is found\
\9\9if t_dlg == nil then\
\9\9\9s_id = new(s_text, \"Yes\", s_npc, s_id)\
\9\9\9addButton(s_id, \"No\")\
\9\9else\
\9\9\9-- And replace text and npc if a dialogdefinition was found\
\9\9\9t_dlg.text = s_text\
\9\9\9t_dlg.npc = s_npc\
\9\9end\
\9\9\
\9\9-- Show the dialog\
\9\9activate(s_id, f_callBack)\
\9\9\
\9else\
\9\9print(\"Calling dialog.quickYesNoDialog() with wrong number and/or type of parameters.\")\
\9end\
end\
\
\
function quickDialog(s_text, f_callBack, s_npc)\
\
\9-- Check parameters; mandatory and/or type checking\
\9if type(s_text) == \"string\" and (f_callBack == nil or type(f_callBack == \"function\")) and (s_npc == nil or type(s_npc)==\"string\") then\
\
\9\9-- Use standard id and get current dialogdefinition\
\9\9local s_id = \"dlgQuickClose\"\
\9\9local t_dlg = getDialog(s_id)\
\9\9\
\9\9-- Make a new dialogdefinition if none is found\
\9\9if t_dlg == nil then\
\9\9\9s_id = new(s_text, \"Close\", s_npc, s_id)\
\9\9else\
\9\9\9-- And replace text and npc if a dialogdefinition was found\
\9\9\9t_dlg.text = s_text\
\9\9\9t_dlg.npc = s_npc\
\9\9end\
\
\9\9-- Show the dialog\
\9\9activate(s_id, f_callBack)\
\9\9\
\9else\
\9\9print(\"Calling dialog.quickDialog() with wrong number and/or type of parameters.\")\
\9end\
end\
\
\
function isActivated(s_id)\
\9if s_id and type(s_id)==\"string\" then\
\9\9return gw.getElement(s_id) ~= s_id\
\9else\
\9\9print(\"isActivated() requires exactly one string parameter (id)\")\
\9end\
end\
\
function getActiveDialogNpc()\
\
\9-- Check parameters; mandatory and/or type checking\
\9if id and type(s_id)==\"string\" then\
\9\
\9\9return tDialog.activeDialog.npc\
\9\9\
\9end\
\9\
\9return nil\
end\
\
\
function getDialog(s_id) \
\
\9-- return dialogdefinition by id\
\9for _, t_dlg in pairs(tDialog.dialogs) do\
\9\9if t_dlg.id == s_id then\
\9\9\9return t_dlg\
\9\9end\
\9end\
end\
\
function calculateDimensions(t_dlg)\
\9-- Define bunch of constants we'll use while drawing\
\9local n_minWindowWidth = 80\
\9local n_dialogPixelWidth = 8.5\
\9local n_dialogPixelHeight = 24\
\9local n_portraitSize = 128\
\
\9-- Calculate window width, starting with minimum width and adding pixels depending on content\
\9local n_windowWidth = n_minWindowWidth\
\
\9-- Add pixels to width for every character in the widest line of the text.\
\9-- But if there's a npc portrait take the largest of either: 1) text from first few lines + pictures width or 2) width of the widest line of all lines\
\9if t_dlg.npc and NPC.Exists(t_dlg.npc) then\
\9\9n_windowWidth = n_windowWidth + math.max(charWidth(t_dlg.text) * n_dialogPixelWidth, charWidth(t_dlg.text, 6) * n_dialogPixelWidth + n_portraitSize + 8)\
\9else\
\9\9n_windowWidth = n_windowWidth + charWidth(t_dlg.text) * n_dialogPixelWidth\
\9end\
\
\9-- Check if the buttons can fit and adjust width if needed\
\9local n_buttonWidth = -20\
\9for _, n_btn in pairs(t_dlg.buttons) do\9\9\9\
\9\9n_buttonWidth = n_buttonWidth + getButtonWidth(charWidth(n_btn)) + 20\
\9end\
\9n_windowWidth = math.max(n_windowWidth, n_minWindowWidth + n_buttonWidth)\
\
\
\9-- Calculate window height, starting with minimum height and adding pixels depending on content\
\9local n_windowHeight = 80\
\9-- Add pixels if an npc is talking, but only if there are less than 6 lines of text\
\9if t_dlg.npc and NPC.Exists(t_dlg.npc) and NPC.GetAttr(t_dlg.npc, \"Portrait\") and countLines(t_dlg.text) < 6 then\
\9\9n_windowHeight = n_windowHeight + n_portraitSize + 30\9\9\
\9\9-- Add 24 pixels to height for each line, but the first 5 lines are free\
\9\9n_windowHeight = n_windowHeight + math.max(0, (countLines(t_dlg.text) - 6) * n_dialogPixelHeight)\
\9else\
\9\9n_windowHeight = n_windowHeight + math.max(0, countLines(t_dlg.text) * n_dialogPixelHeight)\
\9end\
\
\
\9-- Calculate needed height for buttons. First the basic height, then add extra height for evert line of buttontext\
\9n_windowHeight = n_windowHeight + 16\
\9n_windowHeight = n_windowHeight + getButtonMaxLines(t_dlg.buttons) * n_dialogPixelHeight\
\9\
\9return n_windowWidth, n_windowHeight\
end\
\
function onDraw(h_gwelement, h_gui)\
\
\
\9\9local t_dlg = h_gwelement.dialog\
\9\9if (t_dlg == nil) then\
\9\9   print(\"#### dialog is nil\")\
\9\9   return\
\9\9end\
\9\9local s_response = nil\
\9\9local n_windowTileSize = 128\
\9\9\
\9\9local n_windowWidth = 0\
\9\9local n_windowHeight = 0\
\9\9n_windowWidth, n_windowHeight = calculateDimensions(t_dlg)\
\
\9\9\
\9\9if (h_gwelement.width ~= -1) then\
\9\9   n_windowWidth = h_gwelement.width\
\9\9end\
\9\9if (h_gwelement.height ~= -1) then\
\9\9   n_windowHeight = h_gwelement.height\
\9\9end\
\
\9\9-- Round width and height to the nearest higher whole factor of 64\
\9\9n_windowWidth = math.ceil(n_windowWidth / 64) * 64\
\9\9n_windowHeight = math.ceil(n_windowHeight / 64) * 64\
\
\9\9-- Detemine if the width is a multiple of 128 or 64 (needed for drawing the window in right size); yields either 64 or 128\
\9\9local n_multipleWidth = 128 - (64 * ((n_windowWidth / 64) % 2))\
\9\9local n_multipleHeight = 128 - (64 * ((n_windowHeight / 64) % 2))\
\9\9\
\9\9-- Calculate offset of the window (position it in the middle of the screen)\
\9\9local n_windowOffsetX = (h_gui.width - n_windowWidth) / 2\
\9\9local n_windowOffsetY = (h_gui.height - n_windowHeight) / 2\
\
\9\9-- Update gw_element if it was set to auto\
\9\9if (h_gwelement.x == -1) then\
\9\9   h_gwelement.x = n_windowOffsetX\
\9\9end\
\9\9if (h_gwelement.y == -1) then\
\9\9   h_gwelement.y = n_windowOffsetY\
\9\9end\
\9\9if (h_gwelement.width == -1) then\
\9\9   h_gwelement.width = n_windowWidth\
\9\9end\
\9\9if (h_gwelement.height == -1) then\
\9\9   h_gwelement.height = n_windowHeight\
\9\9end\
\
\9\9-- Draw Window in tiles\
\9\9local n_maxX = math.floor(n_windowWidth / n_windowTileSize) - 1\
\9\9if n_multipleWidth == 64 then\
\9\9\9n_maxX = n_maxX + 1\
\9\9end\9\9\
\9\9local n_maxY = math.floor(n_windowHeight / n_windowTileSize) - 1\
\9\9if n_multipleHeight == 64 then\
\9\9\9n_maxY = n_maxY + 1\
\9\9end\
\9\9h_gui.color(255, 255, 255, 255)\9\9\9\9\
\9\9for n_y = 0, n_maxY do\
\9\9\9for n_x = 0, n_maxX do\
\9\9\9\9h_gui.drawImage(\"mod_assets/lnr/textures/dialog/window_\"..getTileName(n_x, n_maxX, n_y, n_maxY, n_multipleWidth, n_multipleHeight, n_windowTileSize)..\".tga\", n_windowOffsetX + n_x * n_windowTileSize, n_windowOffsetY + n_y * n_windowTileSize)\
\9\9\9end\
\9\9end\
\
\9\9-- Draw NPC portrait\
\9\9if t_dlg.npc then\
\9\9\9if NPC.Exists(t_dlg.npc) then\
\9\9\9\9h_gui.drawImage(NPC.GetAttr(t_dlg.npc, \"Portrait\"), n_windowOffsetX + n_windowWidth - 40 - 128, n_windowOffsetY + 40)\
\9\9\9\9h_gui.font(\"tiny\")\
\9\9\9\9h_gui.color(255, 255, 255, 255)\
\9\9\9\9h_gui.drawText(NPC.GetAttr(t_dlg.npc, \"Name\"), n_windowOffsetX + n_windowWidth - 40 - 128 + (128 - charWidth(NPC.GetAttr(t_dlg.npc, \"Name\")) * 8) / 2, n_windowOffsetY + 40 + 128 + 14)\
\9\9\9end\
\9\9end\
\
\
\9\9-- Draw text\
\9if (t_dlg.text and string.len(t_dlg.text)) then\
\9\9drawText(h_gui, t_dlg.text, n_windowOffsetX + 40, n_windowOffsetY + 40)\
\9end\
\
\
\9\9-- Draw buttons\
\9\9local n_maxLines = math.max(0, getButtonMaxLines(t_dlg.buttons) -1);\
\9\9local n_buttonOffsetX = n_windowWidth - 40\
\9\9local n_buttonOffsetY = n_windowHeight - 72 - n_maxLines * 25;\
\9\9\
\9\9for _, n_btn in pairs(t_dlg.buttons) do\
\9\9\
\9\9\9-- Calculate width, height and other numbers\
\9\9\9local n_buttonWidth = getButtonWidth(n_btn)\
\9\9\9local n_buttonHeight = math.ceil(32 + n_maxLines * 25)\
\9\9\9-- Round buttonheight to next higher divider of 16\
\9\9\9n_buttonHeight = math.ceil(n_buttonHeight / 16) * 16\
\9\9\9-- Calculate how many tiles are needed\
\9\9\9local n_maxX = math.ceil(n_buttonWidth / 16) - 1\
\9\9\9local n_maxY = math.ceil(n_buttonHeight / 16) -1\
\
\9\9\9-- Draw the button, made up of 16x16 tiles\
\9\9\9n_buttonX = n_windowOffsetX + n_buttonOffsetX - n_buttonWidth\
\9\9\9n_buttonY = n_windowOffsetY + n_buttonOffsetY \
\9\9\9for n_y = 0, n_maxY do\
\9\9\9\9for n_x = 0, n_maxX do\
\9\9\9\9\9h_gui.drawImage(\"mod_assets/lnr/textures/dialog/button_\"..getTileName(n_x, n_maxX, n_y, n_maxY, 16, 16, 16)..\".tga\", n_buttonX + n_x * 16, n_buttonY + n_y * 16)\
\9\9\9\9end\
\9\9\9end\
\
\9\9\9-- Write the buttontext\
\9\9\9h_gui.font(\"small\")\
\9\9\9h_gui.color(255, 255, 255, 255)\
\9\9\9local n_buttonTextX = n_windowOffsetX + n_buttonOffsetX - n_buttonWidth + (n_buttonWidth - (charWidth(n_btn) + .5) * 7) / 2\
\9\9\9local n_buttonTextY = n_windowOffsetY + n_buttonOffsetY + 6 + (n_buttonHeight - (countLines(n_btn)-1) * 16) / 2\
\9\9\9h_gui.drawText(n_btn, n_buttonTextX, n_buttonTextY)\
\
\9\9\9-- Check if the button has been pressed\
\9\9\9if h_gui.button(n_btn, n_buttonX, n_buttonY, n_buttonWidth, n_buttonHeight) then\
\9\9\9\9s_response = n_btn\
\9\9\9end\
\9\9\9n_buttonOffsetX = n_buttonOffsetX - n_buttonWidth - 20\
\9\9end\
\
\9\9-- Handle if one of the buttons is pressed\
\9\9if s_response then\
\9\9\9\
\9\9\9-- close the current dialog\
\9\9\9deactivate()\
\9\9\9if t_dlg.callBack then\
\9\9\9\9t_dlg.callBack(s_response)\
\9\9\9end\
\9\9\9\
\9\9end\
\9\9\
\9\9-- See if the window itself is pressed\
\9\9if h_gui.button(t_dlg.id, n_windowOffsetX, n_windowOffsetY, n_windowWidth, n_windowHeight - 70) then\
\9\9\9tDialog.startedAt = -1000\
\9\9end\
\9\9\
end\
\
\
function getTileName(n_x, n_n_maxX, n_y, n_n_maxY, n_width, n_height, n_maxSize)\
\9-- Determine what image to use to draw\
\9local s_tileName = \"\"\
\9if n_y == 0 then\
\9\9if n_x == 0 then\
\9\9\9s_tileName = \"\"..n_maxSize..\"_top_left\"\
\9\9else\
\9\9\9if n_x == n_n_maxX then\
\9\9\9\9s_tileName = \"\"..n_width..\"_\"..n_maxSize..\"_top_right\"\9\9\9\9\9\9\9\
\9\9\9else\
\9\9\9\9s_tileName = \"\"..n_maxSize..\"_top_middle\"\
\9\9\9end\
\9\9end\
\9else\
\9\9if n_y == n_n_maxY then\
\9\9\9if n_x == 0 then\
\9\9\9\9s_tileName = \"\"..n_maxSize..\"_\"..n_height..\"_bottom_left\"\
\9\9\9else\
\9\9\9\9if n_x == n_n_maxX then\
\9\9\9\9\9s_tileName = \"\"..n_width..\"_\"..n_height..\"_bottom_right\"\9\9\9\9\9\9\9\
\9\9\9\9else\
\9\9\9\9\9s_tileName = \"\"..n_maxSize..\"_\"..n_height..\"_bottom_middle\"\
\9\9\9\9end\
\9\9\9end\
\9\9else\
\9\9\9if n_x == 0 then\
\9\9\9\9s_tileName = \"\"..n_maxSize..\"_middle_left\"\
\9\9\9else\
\9\9\9\9if n_x == n_n_maxX then\
\9\9\9\9\9s_tileName = \"\"..n_width..\"_\"..n_maxSize..\"_middle_right\"\9\9\9\9\9\9\9\
\9\9\9\9else\
\9\9\9\9\9s_tileName = \"\"..n_maxSize..\"_middle_middle\"\
\9\9\9\9end\
\9\9\9end\
\9\9end\
\9end\
\9return s_tileName\
end\
\
\
function drawText(h_gui, s_text, n_areaX, n_areaY)\
\
\9-- Set font size and color\
\9h_gui.font(\"medium\")\
\9h_gui.color(255, 255, 255, 255)\
\9\
\9-- Determine what part of the text we need to write\
\9local n_textLength = math.floor((getStatistic(\"play_time\") - tDialog.startedAt) * 50)\
\
\9h_gui.drawText(string.sub(s_text, 1, n_textLength), n_areaX, n_areaY + 17)\
end\
\
\
function charWidth(s_text, n_maxLine)\
\
\9local n_maxLen = 0\
\9local n_curLen = 0\
\9local n_lineCount = 0\
\
\9for n_Nr = 1, string.len(s_text) do\9\9\
\9\9if n_maxLine == nil or n_lineCount <= n_maxLine then\
\9\9\9if string.sub(s_text, n_Nr, n_Nr) == \"\\n\" then\
\9\9\9\9n_curLen = 0\
\9\9\9\9n_lineCount = n_lineCount + 1\
\9\9\9else\
\9\9\9\9n_curLen = n_curLen + 1\
\9\9\9end\
\9\9\9if n_curLen > n_maxLen then \
\9\9\9\9n_maxLen = n_curLen\
\9\9\9end\
\9\9end\
\9end\
\9return n_maxLen\
\
end\
\
\
function countLines(s_text)\
\9return string.len(s_text) - string.len(string.gsub(s_text, \"\\n\", \"\")) + 1\
end\
\
\
function getButtonMaxLines(t_buttons)\
\9local n_maxLines = 0\
\9for _, s_btn in pairs(t_buttons) do\
\9\9if countLines(s_btn) > n_maxLines then\
\9\9\9n_maxLines = countLines(s_btn)\
\9\9end\
\9end\
\9return n_maxLines\
end\
\
function getButtonWidth(s_caption)\
\9-- Calculate with, starting with base width\
\9local n_width = 64\
\9-- \9Add pixels depending on character width, but first 2 characters are free\
\9n_width = n_width + math.max(0, charWidth(s_caption) * 8)\
\9-- Round to first whole number of 16\
\9n_width = math.ceil(n_width / 16) * 16\
\9return n_width\
end\
\
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\
-- Backward compatibility functions\
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\
function SetOpen(s_id, bOpen)\
\9print(\"dialog.SetOpen is not supported an_ymore. Use dialog.activate() and dialog.deactivate() instead\")\
end\
\
function SetState(sState)\
\9print(\"SetState is not supported an_ymore! If you think you need states, consult Mahric.\")\
end\
\
function GetState()\
\9print(\"GetState is not supported an_ymore. Instead use isActivated()\")\
\9return \"\"\
end\
\
\
")
