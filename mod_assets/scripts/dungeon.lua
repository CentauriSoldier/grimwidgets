-- This file has been generated by Dungeon Editor 1.3.6

--- level 1 ---

mapName("Unnamed")
setWallSet("dungeon")
playStream("assets/samples/music/dungeon_ambient.ogg")
mapDesc([[
################################
################################
################################
################################
################################
################################
################################
################################
################################
################################
################################
################################
################################
################################
##############...###############
##############...###############
##############...###############
################################
################################
################################
################################
################################
################################
################################
################################
################################
################################
################################
################################
################################
################################
################################
]])
spawn("starting_location", 15,15,0, "starting_location")
spawn("torch_holder", 15,14,0, "torch_holder_1")
	:addTorch()
spawn("script_entity", 17,13,0, "gw")
	:setSource("keyHooks = {}\
elements = {\
\9gui = {},\
\9stats = {},\
\9skills = {},\
\9inventory = {}\
}\
\
\
function addElement(element,hookName)\
\9hookName = hookName or 'gui'\
   \9elements[hookName][element.id] = element\
end\
\
function removeElement(id,hookName)\
\9hookName = hookName or 'gui'\
\9elements[hookName][id] = nil\
end\
\
function drawElements(g,hookName)\
\9hookName = hookName or 'gui'\
\9for id,element in pairs(elements[hookName]) do\
\9\9element:draw(g)\
\9end\
end\
\
function draw(g)\
\9processKeyHooks(g)\
\9drawElements(g,'gui')\
\9gw_events.processEvents(g)\
end\
\
\
function drawInventory(g,champ)\
\9drawElements(g,'inventory')\
end\
\
function drawStats(g,champ)\
\9drawElements(g,'stats')\
end\
\
function drawSkills(g,champ)\
\9drawElements(g,'skills')\
end\
\
function setKeyHook(key,ptoggle,pcallback)\
\9keyHooks[key] = {callback=pcallback,toggle=ptoggle,active=false}\
end\
\
function processKeyHooks(g)\
\9for key,hookDef in pairs(keyHooks) do\
\9\9if hookDef.toggle then\
\9\9\9-- toggle key state and add small threshold so the state doesn't change immediately\
\9\9\9if not keyToggleThresholdTimer and g.keyDown(key) then\
\9\9\9\9hookDef.active = not hookDef.active\
\9\9\9\9local t = spawn('timer',party.level,0,0,1,'keyToggleThresholdTimer')\
\9\9\9\9t:setTimerInterval(0.3)\
\9\9\9\9t:addConnector('activate','gui','destroyKeyToggleThresholdTimer')\
\9\9\9\9t:activate()\
\9\9\9end\
\9\9\9if hookDef.active then\
\9\9\9\9hookDef.callback(g)\
\9\9\9end\9\
\9\9elseif g.keyDown(key) then\
\9\9\9hookDef.callback(g)\
\9\9end\
\9end\
end\
\
function destroyKeyToggleThresholdTimer()\
\9keyToggleThresholdTimer:destroy()\
end\
\
\
\
\
")
spawn("script_entity", 31,31,3, "debug")
	:setSource("\
-- draws size*size grid and shows mouse coordinates in upper left corner\
-- you can enable it by calling debug.grid(100), disable: debug.grid() \
-- currently works only in fullscreen mode because of g.width g.height bug\
\
function grid(size)\
\9if not size then\
\9\9gw.removeElement('grid')\
\9\9return\
\9end\
\9size = size or 100\
\9local grid = {}\
\9grid.id = 'grid'\
\9grid.size = size\
\9grid.draw = function(self,g)\
\9\9local h = math.ceil(g.height/self.size)\
\9\9local w = math.ceil(g.width/self.size)\
\9\9for x = 0,w do\
\9\9\9g.drawRect(x*size,0,1,g.height)\
\9\9end\
\9\9for y = 0,h do\
\9\9\9g.drawRect(0,y*size,g.width,1)\
\9\9end\9\9\
\9\9g.drawText('x: '..g.mouseX..', y:'..g.mouseY,20,20)\
\9\9g.drawText('g.width - '..g.width - g.mouseX..', g.height - '..g.height - g.mouseY,20,40)\
\9end\
\9gw.addElement(grid)\
end\
\
function debugGrid()\
\9grid(100)\
end")
spawn("wall_button", 14,15,3, "wall_button_1")
	:addConnector("toggle", "debug", "debugGrid")
spawn("dungeon_wall_text", 14,15,3, "dungeon_wall_text_1")
	:setWallText("Enable mouse grid")
spawn("gw_event", 16,16,2, "gw_event_1")
	:setSource("-- is this event enabled?\
enabled = true\
\
-- name of the imeage to show\
image = \"mod_assets/images/example-image.dds\"\
\
-- todo: the following x,y coords are temporary.\
--       They should be calculated automatically.\
\
-- image position\
image_x = 40\
image_y = 60\
\
-- text description position\
text_x = 220\
text_y = 60\
\
-- buttons position\
buttons_x = 220\
buttons_y = 160\
buttons_width = 200\
\
-- initial state\
state = 1\
\
-- functions called after specific buttons being pressed\
function onHeal()\
    hudPrint(\"Healing!\")\
    state = 2\
end\
\
function onTalk()\
    hudPrint(\"Dwarf is in too much pain to talk.\")\
end\
\
function onLeave()\
    enabled = false\
end\
\
function onHealed()\
    hudPrint(\"He is healed already!\")\
end\
\
-- defines states. Each entry must have exactly two columns:\
-- first is state number, the second is description shown.\
states = {\
  { 1, \"An injured dwarf lies on the ground before you,\\n\" ..\
       \"nearly unconscious from his wounds.\" },\
  { 2, \"The healed dwarf is happy.\" }\
}\
\
-- defines possible actions in each state. Each entry has\
-- 3 values. First is state number. Second is action name\
-- (will be printed on a button). The third is a function\
-- that will be called when action is taken (i.e. button\
-- is pressed).\
actions = {\
  { 1, \"tend his wounds\", onHeal },\
  { 1, \"talk\", onTalk },\
  { 1, \"leave\", onLeave},\
  { 2, \"healed\", onHealed}\
}\
")
spawn("script_entity", 19,13,1, "gw_events")
	:setSource("-- processes events that are located in the same\
-- location as party\
function processEvents(ctx)\
\
\9local items=\"\"\
    for i in entitiesAt(party.level, party.x, party.y) do\
\9\9if i.class == \"ScriptEntity\" then\
\9\9\9processEncounter(ctx, i)\
\9\9end\
    end\
end\
\
function processEncounter(ctx, eventScript)\
\9if not sanityCheck(eventScript) then\
\9\9return\
\9end\
\
\9local state = eventScript.state\
\9if state == nil then\
\9\9state = 1\
\9end\
\
\9-- Check if image is defined for this event\
\9local image_x = eventScript.x\
\9local image_y = eventScript.y\
\9if not image_x then\
\9    image_x = 20\
\9end\
\9if not image_y then\
\9\9image_y = 20\
\9end\
\9if eventScript.image then\
\9   ctx.drawImage(eventScript.image, image_x, image_y)\
\9end\
\9\
\9\
\9-- Ok, now write a text\
\9local text_x = eventScript.text_x\
\9local text_y = eventScript.text_y\
\9if not text_x then\
\9\9text_x = 200\
\9end\
\9if not text_y then\
\9\9text_y = 50\
\9end\
\9\
\9stateData = eventScript.states[state]\
\9ctx.color(255, 255, 255)\
\9ctx.drawText(stateData[2], text_x, text_y)\
\9\9\
\9local tbl = eventScript.actions\
\9\9\
\9local buttons_x = eventScript.buttons_x\
\9local buttons_y = eventScript.buttons_y\
\9local buttons_width = eventScript.buttons_width\
\9\9\
\9printChoices(ctx, state, tbl, buttons_x, buttons_y, buttons_width)\
end\
\
function printChoices(ctx, current_state, states, x, y, width)\
\9for key1,value in pairs(states) do\
\9\9if value[1] == current_state then\
\9\9\9showButton(ctx, x, y, width, value[2], value[3])\
\9\9\9y = y + 30\
\9\9end\
\9end\
\
end\
\
function sanityCheck(e)\
\9if e.name ~= \"gw_event\" then\
\9\9return false\
\9end\
    if e.states == nil then\
\9\9return false\
\9end\
\9\
\9if e.actions == nill then\
\9\9return false\
\9end\
\9\
\9if (e.enabled ~= true) then\
\9\9return false\
\9end\
\9\
\9return true\
\
end\
\
function showButton(ctx, x, y, width, text, callback)\
    -- draw button1 with text\
    ctx.color(128, 128, 128)\
    ctx.drawRect(x, y, width, 20)\
    ctx.color(255, 255, 255)\
    ctx.drawText(text, x + 10, y + 15)\
\9local name=\"button\"..x..y\
\9local height = 30\
    if ctx.button(\"button1\", x, y, width, height) then\
\9\9callback(ctx)\
\9end\
end")
