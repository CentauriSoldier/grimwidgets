-- This file has been generated by Dungeon Editor 1.3.6

--- level 1 ---

mapName("Unnamed")
setWallSet("dungeon")
playStream("assets/samples/music/dungeon_ambient.ogg")
mapDesc([[
################################
################################
################################
################################
################################
################################
################################
################################
################################
################################
################################
################################
################################
################################
##############...###############
##############...###############
##############...###############
################################
################################
################################
################################
################################
################################
################################
################################
################################
################################
################################
################################
################################
################################
################################
]])
spawn("starting_location", 15,15,0, "starting_location")
spawn("torch_holder", 15,14,0, "torch_holder_1")
	:addTorch()
spawn("script_entity", 17,13,0, "gw")
	:setSource("keyHooks = {}\
elements = {\
\9gui = {},\
\9stats = {},\
\9skills = {},\
\9inventory = {}\
}\
\
\
function addElement(element,hookName)\
\9hookName = hookName or 'gui'\
   \9table.insert(elements[hookName],element)\
end\
\
function removeElement(id,hookName)\
\9hookName = hookName or 'gui'\
\9for i,elem in ipairs(elements[hookName]) do\
\9\9if elem.id == id then\
\9\9\9table.remove(elements[hookName],i)\
\9\9\9return\
\9\9end\
\9end\
end\
\
function drawElements(g,hookName,champion)\
\9hookName = hookName or 'gui'\
\9for id,element in pairs(elements[hookName]) do\
\9\9element:draw(g,champion)\
\9end\
end\
\
function draw(g)\
\
\9processKeyHooks(g)\
\9drawElements(g,'gui')\
\9gw_events.processEvents(g)\
end\
\
\
function drawInventory(g,champ)\
\9drawElements(g,'inventory',champ)\
end\
\
function drawStats(g,champ)\
\9drawElements(g,'stats',champ)\
end\
\
function drawSkills(g,champ)\
\9drawElements(g,'skills',champ)\
end\
\
function setKeyHook(key,ptoggle,pcallback)\
\9keyHooks[key] = {callback=pcallback,toggle=ptoggle,active=false}\
end\
\
function processKeyHooks(g)\
\9for key,hookDef in pairs(keyHooks) do\
\9\9if hookDef.toggle then\
\9\9\9-- toggle key state and add small threshold so the state doesn't change immediately\
\9\9\9if not keyToggleThresholdTimer and g.keyDown(key) then\
\9\9\9\9hookDef.active = not hookDef.active\
\9\9\9\9local t = spawn('timer',party.level,0,0,1,'keyToggleThresholdTimer')\
\9\9\9\9t:setTimerInterval(0.3)\
\9\9\9\9t:addConnector('activate','gw','destroyKeyToggleThresholdTimer')\
\9\9\9\9t:activate()\
\9\9\9end\
\9\9\9if hookDef.active then\
\9\9\9\9hookDef.callback(g)\
\9\9\9end\9\
\9\9elseif g.keyDown(key) then\
\9\9\9hookDef.callback(g)\
\9\9end\
\9end\
end\
\
function destroyKeyToggleThresholdTimer()\
\9keyToggleThresholdTimer:destroy()\
end\
\
\
--- gwElements utiltity functions\
\
\
-- draws whole element, including all its children\
function drawAll(self, ctx)\
\9self.drawSelf(self, ctx)\
\
\9for key,child in pairs(self.children) do\
\9\9child.x = child.x + self.x -- calculate proper offset\
\9\9child.y = child.y + self.y\
\9\9child.draw(child, ctx) -- draw child element\
\9\9child.x = child.x - self.x -- revert back to normal coordinates\
\9\9child.y = child.y - self.y\
\9end\
end\
\
function drawNone()\
end\
\
function drawRect(self, ctx)\
    ctx.color(self.r, self.g, self.b)\
    ctx.drawRect(self.x, self.y, self.width, self.height)\
end\
\
function addChild(parent, child)\
\9table.insert(parent.children, child)\
end\
\
function createElement(id, x, y, width, height)\
    local elem = {}\
    elem.id = id\
\9elem.x = x\
\9elem.y = y\
\9elem.width = width\
\9elem.height = height\
\9elem.parent = nil\
\9elem.children = {}\
\9elem.drawSelf = drawNone\
\9elem.draw = drawAll\
\9return elem\
end\
\
function createRectangle(id, x, y, width, height, r, g, b)\
\9local elem = createElement(id, x, y, width, height)\
\9elem.r = r\
\9elem.g = g\
\9elem.b = b\
\9elem.drawSelf = drawRect\
\9return elem\
end\
\
function drawButton(self, ctx)\
\9drawRect(self, ctx)\
\9ctx.color(255,255,255)\
\9ctx.drawText(self.text, self.x + 5, self.y + 13 + 5)\
end\
\
function stringWidth(text)\
\9local len = 0\
\9for i = 1, string.len(text) do\
\9\9local char = string.sub(text, i, i)\
\9\9if char>='A' and char<='Z' then\
\9\9\9len = len + 12 -- capital letters\
\9\9elseif char>='a' and char<='z' then\
\9\9\9len = len + 9 -- small letters\
\9\9elseif char == ' ' then\
\9\9\9len = len + 5 -- space\
\9\9elseif char>='0' and char<='9' then\
\9\9\9len = len + 9\
\9\9elseif char>='!' and char<='/' then\
\9\9\9len = len + 8\
\9\9else\
\9\9\9len = len + 10\9\9\
\9\9end\
\9end\
\9return len\
end\
\
function createButton(id, x, y, text, r,g,b, callback)\
\9-- rough estimate (letters are typically 13 pixels wide)\
\9local width = stringWidth(text)\
\9local elem = createRectangle(id, x, y, width, 23, r, g, b)\
\9elem.text = text\
\9elem.drawSelf = drawButton\
\9return elem\
end\
")
spawn("script_entity", 12,15,3, "debug")
	:setSource("\
-- draws size*size grid and shows mouse coordinates in upper left corner\
-- you can enable it by calling debug.grid(100), disable: debug.grid() \
-- currently works only in fullscreen mode because of g.width g.height bug\
\
function grid(size)\
\9if not size then\
\9\9gw.removeElement('grid')\
\9\9return\
\9end\
\9size = size or 100\
\9local grid = {}\
\9grid.id = 'grid'\
\9grid.size = size\
\9grid.draw = function(self,g)\
\9\9local h = math.ceil(g.height/self.size)\
\9\9local w = math.ceil(g.width/self.size)\
\9\9for x = 0,w do\
\9\9\9g.drawRect(x*self.size,0,1,g.height)\
\9\9end\
\9\9for y = 0,h do\
\9\9\9g.drawRect(0,y*self.size,g.width,1)\
\9\9end\9\9\
\9\9g.drawText('x: '..g.mouseX..', y:'..g.mouseY,20,20)\
\9\9g.drawText('g.width - '..g.width - g.mouseX..', g.height - '..g.height - g.mouseY,20,40)\
\9end\
\9gw.addElement(grid)\
end\
\
function debugGrid()\
\9grid(100)\
end")
spawn("wall_button", 14,15,3, "wall_button_1")
	:addConnector("toggle", "debug", "debugGrid")
spawn("dungeon_wall_text", 14,15,3, "dungeon_wall_text_1")
	:setWallText("Enable mouse grid")
spawn("gw_event", 16,16,2, "gw_event_1")
	:setSource("-- is this event enabled?\
enabled = true\
\
-- name of the imeage to show\
image = \"mod_assets/images/example-image.dds\"\
\
-- todo: the following x,y coords are temporary.\
--       They should be calculated automatically.\
\
-- image position\
image_x = 40\
image_y = 60\
\
-- text description position\
text_x = 220\
text_y = 60\
\
-- buttons position\
buttons_x = 220\
buttons_y = 160\
buttons_width = 200\
\
-- initial state\
state = 1\
\
-- functions called after specific buttons being pressed\
function onHeal()\
    hudPrint(\"Healing!\")\
    state = 2\
end\
\
function onTalk()\
    hudPrint(\"Dwarf is in too much pain to talk.\")\
end\
\
function onLeave()\
    enabled = false\
end\
\
function onHealed()\
    hudPrint(\"He is healed already!\")\
end\
\
-- defines states. Each entry must have exactly two columns:\
-- first is state number, the second is description shown.\
states = {\
  { 1, \"An injured dwarf lies on the ground before you,\\n\" ..\
       \"nearly unconscious from his wounds.\" },\
  { 2, \"The healed dwarf is happy.\" }\
}\
\
-- defines possible actions in each state. Each entry has\
-- 3 values. First is state number. Second is action name\
-- (will be printed on a button). The third is a function\
-- that will be called when action is taken (i.e. button\
-- is pressed).\
actions = {\
  { 1, \"tend his wounds\", onHeal },\
  { 1, \"talk\", onTalk },\
  { 1, \"leave\", onLeave},\
  { 2, \"healed\", onHealed}\
}\
")
spawn("script_entity", 19,13,1, "gw_events")
	:setSource("-- processes events that are located in the same\
-- location as party\
function processEvents(ctx)\
\
\9local items=\"\"\
    for i in entitiesAt(party.level, party.x, party.y) do\
\9\9if i.class == \"ScriptEntity\" then\
\9\9\9processEncounter(ctx, i)\
\9\9end\
    end\
end\
\
function processEncounter(ctx, eventScript)\
\9if not sanityCheck(eventScript) then\
\9\9return\
\9end\
\
\9local state = eventScript.state\
\9if state == nil then\
\9\9state = 1\
\9end\
\
\
\9-- Check if image is defined for this event\
\9local image_x = eventScript.x\
\9local image_y = eventScript.y\
\9if not image_x then\
\9    image_x = 20\
\9end\
\9if not image_y then\
\9\9image_y = 20\
\9end\
\9if eventScript.image then\
\9   ctx.drawImage(eventScript.image, image_x, image_y)\
\9end\
\9\
\9\
\9-- Ok, now write a text\
\9local text_x = eventScript.text_x\
\9local text_y = eventScript.text_y\
\9if not text_x then\
\9\9text_x = 200\
\9end\
\9if not text_y then\
\9\9text_y = 50\
\9end\
\9\
\9stateData = eventScript.states[state]\
\9ctx.color(255, 255, 255)\
\9ctx.drawText(stateData[2], text_x, text_y)\
\9\9\
\9local tbl = eventScript.actions\
\9\9\
\9local buttons_x = eventScript.buttons_x\
\9local buttons_y = eventScript.buttons_y\
\9local buttons_width = eventScript.buttons_width\
\9\9\
\9printChoices(ctx, state, tbl, buttons_x, buttons_y, buttons_width)\
end\
\
function printChoices(ctx, current_state, states, x, y, width)\
\9for key1,value in pairs(states) do\
\9\9if value[1] == current_state then\
\9\9\9showButton(ctx, x, y, width, value[2], value[3])\
\9\9\9y = y + 30\
\9\9end\
\9end\
\
end\
\
function sanityCheck(e)\
\9if e.name ~= \"gw_event\" then\
\9\9return false\
\9end\
    if e.states == nil then\
\9\9return false\
\9end\
\9\
\9if e.actions == nill then\
\9\9return false\
\9end\
\9\
\9if (e.enabled ~= true) then\
\9\9return false\
\9end\
\9\
\9return true\
\
end\
\
function showButton(ctx, x, y, width, text, callback)\
    -- draw button1 with text\
    ctx.color(128, 128, 128)\
    ctx.drawRect(x, y, width, 20)\
    ctx.color(255, 255, 255)\
    ctx.drawText(text, x + 10, y + 15)\
\9local name=\"button\"..x..y\
\9local height = 30\
    if ctx.button(\"button1\", x, y, width, height) then\
\9\9callback(ctx)\
\9end\
end")
spawn("script_entity", 29,31,2, "spell_book")
	:setSource("-- For testing/developement purposes\
-- I hope that this case is complex enough to show the possible flaws on grimwigets.\
\
spells = {}\
offset = {\
\9x=20,\
\9y=20,\
\9line_h = 20,\
}\
runeMap = {\
\9A='rune1_fire',\
\9B='rune2_death',\
\9C='rune3_air',\
\9D='rune4_spirituality',\
\9E='rune5_balance',\
\9F='rune6_physicality',\
\9G='rune7_earth',\
\9H='rune8_life',\
\9I='rune9_water'\
}\
function activate()\
\
\
end\
\
function setSpells(pspells)\
\9spells = {}\
\9i = 1\
\9for spellName,def in pairs(pspells) do\
\9\9table.insert(spells,i,def)\
\9\9i = i + 1\
\9end\
end\
\
function drawSpellBook(self,g,champion)\
\9if champion and champion:getClass() ~= 'Mage' then\
\9\9gw.removeElement('spell_book_runes','skills')\
\9\9return\
\9end\
\9local x = spell_book.offset.x\
\9local y = spell_book.offset.y\
\9\
\9g.color(255,255,255,200)\
\9g.drawImage(\"mod_assets/textures/book_900.tga\",x,y)\
\9\
\9g.font('medium')\
\9local row = 1\
\9for name,spell in pairs(spells) do\
\9\9if g.button(spell.name..'_b',x,y + row * 20,300,20) then\
\9\9\9if (spell.runes) then\
\9\9\9\9local rune_images = {}\
\9\9\9\9\
\9\9\9\9for i=1,#spell.runes do\
\9\9\9\9\9local runeChar = string.sub(spell.runes,i,i)\
\9\9\9\9\9rune_images[i] = 'mod_assets/textures/'..runeMap[runeChar]..'.tga'\
\9\9\9\9end\
\9\9\9\9\
\9\9\9\9local runes = {\
\9\9\9\9\9id='spell_book_runes',\
\9\9\9\9\9images = rune_images,\
\9\9\9\9\9description = spell.description \
\9\9\9\9}\
\9\9\9\9runes.draw = function(self,g,champ)\
\9\9\9\9\9g.font('small')\
\9\9\9\9\9for i,imagePath in ipairs(self.images) do\
\9\9\9\9\9\9g.drawImage(imagePath,500+100*i,200)\
\9\9\9\9\9end\
\9\9\9\9\9g.drawText(self.description,500,300)\
\9\9\9\9end\
\9\9\9\9gw.removeElement('spell_book_runes','skills')\
\9\9\9\9gw.addElement(runes,'skills')\
\9\9\9\9\
\9\9\9end\
\9\9\9\
\9\9end\9\9\
\9\9\
\9\9g.color(237,175,135,255)\
\9\9g.drawRect(x + 30 ,y+row*20,19,19)\
\9\9\
\
\9\9g.color(250,250,250,255)\
\9\9g.drawText(spell.uiname,x + 50, y + 20 + row*20)\
\9\9row = row + 1\
\9end\
end\
\
-- testing\
setSpells{\
\9{name='fireburst',uiname='Fireburst',runes='A',description='Caster creates a quick burst of fire in front of him'},\
\9{name='ice_shards',uiname='Ice Shards',runes='GI',description='Caster shoots a flurry of ice shards in front of him'}\
}\
\
\9\
local e = {}\
e.id = 'spell_book_mage'\
e.draw = spell_book.drawSpellBook\
--gw.setKeyHook('m',true,e.draw)\
gw.addElement(e,'skills')\
\
")
spawn("script_entity", 28,31,2, "compass")
	:setSource("-- This example draws a compass as a GUI element. Depending on which\
-- activation mode is chosen, it can be visible all time, toggled\
-- with 'c' key or shown only when 'c' is pressed.\
\
-- draws actual compass\
-- this function is called when compass is visible all time\
function drawCompass(self, g)\
\9local x = 10\
\9local y = g.height - 200\
\9\
\9local dir = string.sub(\"NESW\", party.facing + 1, party.facing + 1)\
\9g.drawImage(\"mod_assets/textures/compass_full_\"..dir..\".tga\", x, y)\
end\
\
-- this is a simple wrapper function that is called as key press\
-- hook. It calls drawCompass function.\
function callback(g)\
\9drawCompass(self, g)\
end\
\
local e = {}\
e.id = 'compass'\
e.draw = drawCompass\
e.callback = callback\
\
-- uncomment this to enabled/disable compass by pressing C\
gw.setKeyHook('c', true, e.callback)\
\
-- Uncomment this to show compass by pressing C\
-- gw.setKeyHook('c', false, e.callback)\
\
-- Uncomment this to have compass permanently visible\
-- gw.addElement(e,'gui')")
spawn("wall_button", 14,16,3, "wall_button_2")
	:addConnector("toggle", "script_entity_1", "drawExample")
spawn("script_entity", 12,16,2, "script_entity_1")
	:setSource("-- This function showcases how gwElements may be stacked together\
function drawExample()\
\
\9local rect1 = gw.createRectangle('rect1', 100, 50, 400, 150, 255, 255, 0)\
\9local rect2 = gw.createRectangle('rect2', 10, 10, 50, 50, 0, 0, 255)\
\9local rect3 = gw.createRectangle('rect3', 10, 10, 30, 30, 255, 0, 0)\
\9local button1 = gw.createButton('button1', 70, 10, \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", 0,255,0, nil)\
\9local button2 = gw.createButton('button2', 70, 40, \"abcdefghijklmnopqrstuvwxyz\", 0,255,0, nil)\
\9local button3 = gw.createButton('button3', 70, 70, \"1234567890\", 0,255,0, nil)\
\9local button4 = gw.createButton('button4', 70, 100, \"!@#$%^&*()-,.'\", 0,255,0, nil)\
\9gw.addChild(rect1, rect2)\
\9gw.addChild(rect2, rect3) -- rect3 in rect2, which is in rect1\
\9gw.addChild(rect1, button1)\
\9gw.addChild(rect1, button2)\
\9gw.addChild(rect1, button3)\
\9gw.addChild(rect1, button4)\
\
\
\9gw.addElement(rect1, 'gui')\
end\
")
spawn("dungeon_wall_text_long", 14,16,3, "dungeon_wall_text_long_1")
	:setWallText("Shows gwElements (several gui elements\
that are hierarchically organized)")
